#! /bin/sh
show_version() {
	wr <<- .
	$APP version 14.190.1

	(c) 2014 by Guenther Brunthaler.
	This script is free software.
	Distribution is permitted under the terms of the GPLv3.
.
}
APP=${0##*/}

wr() {
	if test -n "$fmt"
	then
		test -z "$*" && set -- -c
		"$fmt" -w "$LINEWIDTH" "$@"
	elif test -n "$fold"
	then
		"$fold" -s -w $LINEWIDTH
	else
		cat
	fi
}
LINEWIDTH=72
fmt=`which fmt 2> /dev/null` || fmt=
if test -z "$fmt"
then
	fold=`which fold 2> /dev/null` || fold=
fi

need() {
	which "$1" > /dev/null 2>& 1 && return
	echo "Cannot run: Command '$1' is not installed." >& 2
	false || exit
}

rmie() {
	while test $# != 0
	do
		test -e "$1" && rm -- "$1"
		shift
	done
}

xmessageMBCS() {
	local cs file
	file=$1; shift
	cs=ISO-8859-15 # xmessage does not support UTF-8.
	iconv -ct "$cs" "$file" \
	| LC_CTYPE="$cs" xmessage "$@" -file - 2> /dev/null || :
}

# Set $button to the name of the button pressed.
# First argument is always default button.
# Last argument is "cancel/abort" and will generate a failure return code.
request() {
	local dfl abort
	dfl=; button=
	test $# = 1 && set -- "$@" Quit
	test $# -ge 2
	while test $# != 0
	do
		test -z "$dfl" && dfl=$1
		test $# = 1 && abort=$1
		button=$button${button:+,}$1; shift
	done
	exec 3>& -
	button=`
		xmessageMBCS "$progress" \
			-buttons "$button" -default "$dfl" -print \
			2> /dev/null || :
	` || button=$abort
	exec 3> "$progress"
	test -n "$button"
	test x"$button" != x"$abort" || return
}

# $CHARSET needs to be set (an empty string for autoprobe).
encrypt() {
	OUT=$TDIR/out_local.txt
	xclip -selection clipboard -o > "$OUT"
	cat <<- . >& 3

	The output message has been fetched from the clipboard.
.
	OUT_DEC=$TDIR/out.txt
	local cs
	for cs in $CHARSET ISO-8859-1 ISO-8859-15 UTF-8 die
	do
		iconv -t "$cs" "$OUT" > "$OUT_DEC" && break
		test x"$cs" != x"die"
	done
	if test x"$cs" = x"$CHARSET"
	then
		cat <<- . >& 3

	It has been converted to the same character set as the original
	decrypted input message ($CHARSET).
.
	else
		echo "It has been converted to character set $cs." >& 3
	fi
	OUT_ENC=$TDIR/out.asc
	rmie "$OUT_ENC"
	set -- gpg2 --encrypt --output "$OUT_ENC" --armor
	while read recv
	do
		echo "Encrypting to receiver $recv." >& 3
		set -- "$@" -r "$recv"
	done < "$RECV"
	"$@" "$OUT_DEC"

	OUT_ENC_HDR=$TDIR/out_patched.asc
	sed "
		/^---.*BEGIN .*MESSAGE/ {
			p; s/.*/Charset: $cs/
		}
	" "$OUT_ENC" > "$OUT_ENC_HDR"

	xclip -selection clipboard -i "$OUT_ENC_HDR"

	cat <<- . >& 3
	The encrypted output message is now available as the clipboard's new
	contents.
.
}

reply() {
	IN_ENC=$TDIR/in.asc
	{
		xclip -selection clipboard -o
		echo
	} > "$IN_ENC"
	test -s "$IN_ENC"

	CHARSET=`grep -i '^Charset:' "$IN_ENC" | awk '{print $2}'` || :
	if test -n "$CHARSET"
	then
		echo "Message encoding is $CHARSET." >& 3
	else
		CHARSET=ISO-8859-1
		echo "Assuming message encoding as $CHARSET." >& 3
	fi

	IN_DEC=$TDIR/in_foreign.txt
	DEC_LOG=$TDIR/dec_log.txt
	RECS=$TDIR/dec_receivers.txt
	KEYS=$TDIR/dec_keys.txt
	echo "Decrypting message..." >& 3
	rmie "$IN_DEC"
	gpg2 --keyid-format=long --output="$IN_DEC" "$IN_ENC" \
		2> "$DEC_LOG"
	sed 's/^gpg:.*, ID \([0-9A-F]\{16\}\),.*/\1/; t; d' \
		"$DEC_LOG" | sort > "$KEYS"
	test -s "$IN_DEC"; test -s "$KEYS"

	OWN=$TDIR/own_key_ids.txt
	if test ! -e "$OWN" || test ! -s "$OWN"
	then
		gpg2 --list-secret-keys --with-colons | grep '^\(sec\|ssb\):' \
			| cut -d: -f5 | sort > "$OWN"
		test -s "$OWN"
	fi

	RECV=$TDIR/receiver_ids.txt
	join -v1 "$KEYS" "$OWN" > "$RECV"
	
	IN=$TDIR/in.txt
	iconv -f "$CHARSET" "$IN_DEC" > "$IN"
	
	xclip -selection clipboard -i "$IN"
	cat <<- . >& 3

	The decrypted message has been converted to the local character set
	and is now available as the clipboard's new contents.
	
	Reply to the encrypted e-mail message now, and insert the text from
	the clipboard as quoted text.
	
	Then finish the e-mail by adding your reply text, and copy the whole
	resulting e-mail text back into the clipboard.
	
	Finally, press "Encrypt" to encrypt the e-Mail to the original sender,
	press "Quit" to terminate the application prematurely, press "Cancel"
	to abort the reply operation in progress and return to the main menu
	instead.
.
	request Encrypt Cancel Quit || return
	test $button = Cancel && return
	encrypt || return
	cat <<- . >& 3
	
	Paste it into the already-open reply e-mail message window now,
	replacing the previously edited unencrypthed output message with the
	encrypted version.
	
	Then send the reply e-mail.
.
}

new() {
	local r any

	DEC_LOG=$TDIR/dec_log.txt
	{
		xclip -selection clipboard -o
		echo
	} > "$DEC_LOG"
	test -s "$DEC_LOG"

	RECV=$TDIR/receiver_ids.txt
	{
		{
			cat "$DEC_LOG"; echo
			x=A-Fa-f0-9; nx="[^$x]"; x="[$x]"
			s='^'$nx'*\('$x'\{6,\}\)'$nx'*'
			sed 's/'"$s"'/<\1>\\n/g; t; d' "$DEC_LOG"
			s='^[^<]*<\([^<>]\+\)>[^<]*'
			sed 's/'"$s"'/\1\\n/g; t; d' "$DEC_LOG"
		} | awk -F '\\\\n' '{for (i= 1; i <= NF; ++i) print $i}' \
		| {
			s=`printf '[\t\b\v ]'`
			sed 's/^'"$s"'*//; s/'"$s"'*$//' | sed '/^$/d'
		} | sort -u \
		| while read recv
		do
			gpg2 --list-public-keys --with-colons \
				--fixed-list-mode -- "$recv" || :
		done \
		| cut -d: -f1,2,5,12 | grep '^pub:[mfu].*:.*:[^:Dd]*$' \
		| grep ':[^:]*E[^:]*$' | cut -d: -f3 | sort -u
	} 2> /dev/null > "$RECV"
	
	{
		echo "The following receivers have been selected:"
		echo
		set -- gpg2 --list-public-keys
		any=
		while read r
		do
			set -- "$@" "$r"
			any=y
		done < "$RECV"
		if test -z "$any"
		then
			{ echo "ERROR: No recpients match!"; echo; } >& 3
			return
		fi
		"$@"
	} >& 3
	cat <<- . >& 3

	Now copy the new message into the clipboard, encoded using the
	configured character set of your locale.
.
	request Encrypt || return
	encrypt || return
	cat <<- . >& 3
	
	Paste it into a new e-mail message window.
	
	Then set subject and recipient and send the e-mail.
.
}


set -e
if ! xauth -q nlist > /dev/null
then
	echo "GUI is not accessible!" >& 2
	false || exit
fi
need xmessage
need mktemp

TDIR=`mktemp --tmpdir -d "$APP".XXXXXXXXXX`
test -n "$TDIR"
test -d "$TDIR"

cleanup() {
	echo "Failed!" >& 2
	test -n "$errfile" && exec 2>& -
	test -n "$progress" && exec 3>& -
	exec 2> /dev/null
	if test -z "$OK" && test -n "$errfile"
	then
		xmessageMBCS "$errfile" -buttons "Terminate" || :
	fi
	rm -r -- "$TDIR" || :
}
OK=
errfile=
progress=
trap cleanup 0

errfile=$TDIR/errfile
exec 2> "$errfile"
progress=$TDIR/progress
exec 3> "$progress"

true && success=$?; false || failure=$?

{ show_version; echo; } >& 3

need awk
need gpg2
need iconv
need join
need xclip

gpgax=gpg-agent
phase=try
while
	test -z "$GPG_AGENT_INFO" || {
		t=${GPG_AGENT_INFO%:*}
		test x"$t" = x"$GPG_AGENT_INFO"
	} || {
		t2=${t##*:}
		test x"$t2" = x"$t"
	} || {
		t=/proc/$t2/exe
		test ! -L "$t"
	} || ! t=`readlink "$t"` || test -z "$t" || test ! -f "$t" \
	|| test x"${t##*/}" != test x"$gpgax"
do
	test -n "$HOME"
	cache=$HOME/.cache
	if test ! -d "$cache"
	then
		phase=new
		mkdir -- "$cache"
	fi
	cache=$cache/gpg-agent.env
	if test ! -f "$cache"
	then
		phase=new
		test ! -e "$cache"
		> "$cache"
		chmod 600 -- "$cache"
	fi
	case $phase in
		try)
			echo "Trying to re-load saved $gpgax environment" \
				"from '$cache'..." >& 3
			phase=new;;
		new)
			echo "Launching $gpgax..." >& 3
			need "$gpgax"
			"$gpgax" -q --daemon > "$cache"
			phase=fail
			;;
		*)
			echo "Could not start $gpgax!" >& 2
			false
	esac
	. "$cache"
done
if test $phase = try
then
	echo 'Using existing settings from $GPG_AGENT_INFO.' >& 3
fi

while :
do
	cat <<- . >& 3
	In order to decrypt an existing PGP message for subsequent reply, copy
	the encrypted message into the clipboard, then press "Reply".
	
	For encrypting a new PGP message, copy the recipients'
	e-mail-addresses or PGP key IDs into the clipboard, then press "New".
	
	Or press "Exit" to quit this application.
.
	request Reply New Exit || break
	if test $button = Reply
	then
		reply || break
	else
		new || break
	fi
done
OK=y
